<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <link rel="stylesheet" href="default.css">
    </head>
    <body>
        <h1>Ubikom: Secure and Private Email, Based on Self-Sovereign Identity</h1>
        <p><a href="mailto:lgx@ubikom.cc">lgx@ubikom.cc</a></p>
        <h2>Design Goals</h2>
        <p>
            Ubikom is based on the following design goals:
            <ul>
            <li>User identity must be controlled by the user - the concept known as <a href="https://en.wikipedia.org/wiki/Self-sovereign_identity">Self-Sovereign Identity.</a></li>
            <li>Communications must be private and secure by default. In the Ubikom ecosystem, there is no way to send a message without signing and encrypting it.</li>
            <li>Core software must be open-source</li>
            <li>There is no central authority controlling the Ubikom ecosystem. Eventually, the identity registry will be decentralized and distributed</li>
            <li>Getting your identity must be free, so everyone (and everything) can get it easily</li>
            <li>Sending and receiving messages must be absolutely trivial</li>
            <li>Users must have freedom to decide how to compromise between security and convenience. Users might decide to delegate their authority to a third-party system, a decision that can be revoked at any time</li>
            </ul>
        </p>
        <h2>Encryption</h2>
        <p>Ubikom uses secp256k Elliptic Curve Cryptography, same as Bitcoin. We use it to produce private and public key, 
            encrypt messages using the symmetric encryption key derived from the sender's private key and receiver's public key.
            The receiver can re-construct the symmetric encryption key, and decrypt the message. No one else is able to decrypt the
            message, since receiver's private key is required for decryption.
        </p>
        <h2>Identity Registry</h2>
        <p>In order to locate other users public key, we use the identity registry. The registry is a key-value store, which 
            contains the following entities:
            <ul>
                <li>Public keys and related data (a public key may be disabled, for example)</li>
                <li>Names. Each name is associated with a public key.</li>
                <li>Addresses. Each address is keyed by name and protocol, and basically means "if you want to communicate with me 
                    using this protocol, this is where you can find me".
                </li>
            </ul>
        </p>
        <p>It is absolutely essential that the identity registry is decentralized and distributed, without any central authority 
            controlling it. In the first iteration, the identity registry is centralized to allow basic end-to-end functionality.
        </p>
        <h2>Email Proxy</h2>
        <p>To make everything working end-to-end without coding new email clients, we want to take advantage of the existing
            clients. A translation layer is required to convert gRPC calls (used between Ubikom components) to SMTP/POP3 calls
            used by email clients. The encryption and decryption is handled on the fly by the email proxy.
        </p>
        <p>
            Ideally, each user would run email proxy on their machine, to keep control over their private keys. This requirement, 
            however, would limit the adoption, and would not answer the question of how to handle potential web clients. 
        </p>
        <p>
            If we were to run public email proxy, we would need a way to transmit user credentials to the proxy, without risk
            of losing control of the user's private key. To do that, we use concept of delegating limited authority to the Email
            proxy while keeping the ultimate authority over user's private key.
        </p>
        <h2>Delegating Authority</h2>
        <p>
            When a private key is created and registered, it is required to perform any action associated with this key, which include:
            <ul>
                <li>Encrypting and decryption messages</li>
                <li>Registering names</li>
                <li>Registering addresses</li>
                <li>Disabling the key</li>
            </ul>
        </p>
        <p>
            Email proxy only needs encryption and decryption. If we were to send user's private key to the public proxy,
            we would risk the key being compromised, allowing all the operations listed above.
        </p>
        <p>
            To handle this situation, we introduce another key, which is registered as a child of the main key. Child keys are only
            allowed to perform encryption and decryption, but none of other operations.
        </p>
        <p>
            Child key is transmitted to the email proxy in a secure way, and then used to encrypt outgoing messages and decrypt 
            incoming messages.
        </p>
        <p>
            If the child key is compromised, the user would use the main key to generate another email key, disable the previous one,
            and transfer name and address registration to the new key.
        </p>
        <p>
            In fact, it might be a good idea to do email key rotation on a regular basis.
        </p>
    </body>
</html>